.. contents:: Содержание
   :depth: 5

The OAuth 2.0 Authorization Framework
=====================================

2. Регистрация клиента
----------------------

Перед запуском протокола клиент регистрируется на сервере авторизации. Средства, с помощью которых клиент регистрируется на сервере авторизации, выходят за рамки данной спецификации, но обычно включают взаимодействие конечного пользователя с регистрационной формой HTML.

Регистрация клиента не требует прямого взаимодействия между клиентом и сервером авторизации. При поддержке сервера авторизации регистрация может полагаться на другие средства для установления доверия и получения требуемых свойств клиента (например, URI перенаправления, типа клиента). Например, регистрация может быть выполнена с использованием утверждения, выданного самостоятельно или третьей стороной, или сервером авторизации, выполняющим обнаружение клиента с использованием доверенного канала.

При регистрации клиента разработчик клиента ОБЯЗАН:

* указать тип клиента, как описано в разделе 2.1
* предоставить свои URI перенаправления клиента, как описано в Разделе 3.1.2
* включать любую другую информацию, требуемую сервером авторизации (например, название приложения, веб-сайт, описание, изображение логотипа, принятие юридических условий).

2.1. Типы клиентов
~~~~~~~~~~~~~~~~~~

OAuth определяет два типа клиентов в зависимости от их способности безопасно аутентифицироваться с помощью сервера авторизации (т.е. Способности поддерживать конфиденциальность своих учетных данных клиента):

confidential
    Клиенты, способные поддерживать конфиденциальность своих учетных данных (например, клиент, реализованный на защищенном сервере с ограниченным доступом к учетным данным клиента) или способные к безопасной аутентификации клиента с использованием других средств.

public
    Клиенты, неспособные поддерживать конфиденциальность своих учетных данных (например, клиенты, выполняющиеся на устройстве, используемом владельцем ресурса, таком как установленное собственное приложение или приложение на основе веб-браузера), и неспособные к безопасной аутентификации клиента с помощью любых других средств.

Обозначение типа клиента основано на определении сервером авторизации безопасной аутентификации и приемлемых уровнях раскрытия учетных данных клиента. Серверу авторизации НЕ СЛЕДУЕТ делать предположения о типе клиента.

Клиент может быть реализован как распределенный набор компонентов, каждый с различным типом клиента и контекстом безопасности (например, распределенный клиент с конфиденциальным серверным компонентом и общедоступным компонентом на основе браузера). Если сервер авторизации не поддерживает таких клиентов или не дает рекомендаций по их регистрации, клиент ДОЛЖЕН зарегистрировать каждый компонент как отдельный клиент.

Эта спецификация была разработана для следующих клиентских профилей:

веб приложение (web application)
    Веб-приложение - это конфиденциальный клиент, работающий на веб-сервере. Владельцы ресурсов получают доступ к клиенту через пользовательский интерфейс HTML, отображаемый в пользовательском агенте на устройстве, используемом владельцем ресурса. Учетные данные клиента, а также любой токен доступа, выданный клиенту, хранятся на веб-сервере и не доступны для владельца ресурса.

приложение на основе пользовательского агента (user-agent-based application)
    Приложение на основе пользовательского агента - это общедоступный клиент, в котором клиентский код загружается с веб-сервера и выполняется в рамках пользовательского агента (например, веб-браузера) на устройстве, используемом владельцем ресурса. Данные протокола и учетные данные легко доступны (и часто видны) владельцу ресурса. Поскольку такие приложения находятся в пользовательском агенте, они могут беспрепятственно использовать возможности пользовательского агента при запросе авторизации.

собственное приложение (native application)
    Собственное приложение - это общедоступный клиент, установленный и выполняемый на устройстве, используемом владельцем ресурса. Данные протокола и учетные данные доступны владельцу ресурса. Предполагается, что любые учетные данные для аутентификации клиента, включенные в приложение, могут быть извлечены. С другой стороны, динамически выдаваемые учетные данные, такие как токены доступа или токены обновления, могут получить приемлемый уровень защиты. Как минимум, эти учетные данные защищены от враждебных серверов, с которыми приложение может взаимодействовать. На некоторых платформах эти учетные данные могут быть защищены от других приложений, находящихся на том же устройстве.

2.2. Идентификация клиента
~~~~~~~~~~~~~~~~~~~~~~~~~~

Сервер авторизации выдает зарегистрированному клиенту идентификатор клиента - уникальную строку, представляющую регистрационную информацию, предоставленную клиентом. Идентификатор клиента не секрет; он предоставляется владельцу ресурса и НЕ ДОЛЖЕН использоваться отдельно для аутентификации клиента. Идентификатор клиента уникален для сервера авторизации.

Размер строки идентификатора клиента не определен данной спецификацией. Клиент должен избегать предположений о размере идентификатора. Серверу авторизации СЛЕДУЕТ задокументировать размер любого выдаваемого им идентификатора.

2.3. Проверка подлинности клиента
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если тип клиента является конфиденциальным, клиент и сервер авторизации устанавливают метод аутентификации клиента, подходящий для требований безопасности сервера авторизации. Сервер авторизации МОЖЕТ принимать любую форму аутентификации клиента, отвечающую его требованиям безопасности.

Конфиденциальным клиентам обычно выдается (или устанавливается) набор учетных данных клиента, используемых для аутентификации на сервере авторизации (например, пароль, пара открытого / закрытого ключей). Сервер авторизации МОЖЕТ установить метод аутентификации клиента с общедоступными клиентами. Однако сервер авторизации НЕ ДОЛЖЕН полагаться на общедоступную аутентификацию клиента с целью идентификации клиента.

Клиент НЕ ДОЛЖЕН использовать более одного метода аутентификации в каждом запросе.

2.3.1. Пароль клиента
^^^^^^^^^^^^^^^^^^^^^

Клиенты, владеющие клиентским паролем, МОГУТ использовать схему аутентификации HTTP Basic, как определено в [RFC2617], для аутентификации на сервере авторизации. Идентификатор клиента кодируется с использованием алгоритма кодирования ``application/x-www-form-urlencoded`` согласно Приложению B, и закодированное значение используется в качестве имени пользователя; пароль клиента кодируется с использованием того же алгоритма и используется в качестве пароля. Сервер авторизации ДОЛЖЕН поддерживать схему аутентификации HTTP Basic для аутентификации клиентов, которым был выдан пароль клиента.

Например (с дополнительными разрывами строк только для отображения)::

    Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3

В качестве альтернативы сервер авторизации МОЖЕТ поддерживать включение учетных данных клиента в тело запроса с использованием следующих параметров:

client_id
    ОБЯЗАТЕЛЬНЫЙ. Идентификатор клиента, выданный клиенту во время процесса регистрации, описанного в разделе 2.2.

client_secret
    ОБЯЗАТЕЛЬНЫЙ. Секрет клиента. Клиент МОЖЕТ опустить параметр, если секрет клиента является пустой строкой.

Включение учетных данных клиента в тело запроса с использованием этих двух параметров НЕ РЕКОМЕНДУЕТСЯ и ДОЛЖНО быть ограничено клиентами, которые не могут напрямую использовать схему аутентификации HTTP Basic (или другие схемы аутентификации HTTP на основе пароля). Параметры могут быть переданы только в теле запроса и НЕ ДОЛЖНЫ включаться в URI запроса.

Например, запрос на обновление токена доступа (раздел 6) с использованием параметров тела (с дополнительными разрывами строк только для отображения)::

    POST /token HTTP/1.1
    Host: server.example.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
    &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw

Сервер авторизации ДОЛЖЕН требовать использования TLS, как описано в разделе 1.6, при отправке запросов с использованием аутентификации по паролю.

Поскольку этот метод аутентификации клиента включает в себя пароль, сервер авторизации ДОЛЖЕН защищать любую конечную точку, использующую его, от brute force атак.

2.3.2. Другие методы аутентификации
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Сервер авторизации МОЖЕТ поддерживать любую подходящую схему аутентификации HTTP, соответствующую его требованиям безопасности. При использовании других методов аутентификации сервер авторизации ДОЛЖЕН определить соответствие между идентификатором клиента (регистрационной записью) и схемой аутентификации.

2.4. Незарегистрированные клиенты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Эта спецификация не исключает использования незарегистрированных клиентов. Однако использование таких клиентов выходит за рамки данной спецификации и требует дополнительного анализа безопасности и анализа влияния на совместимость.

3. Конечные точки протокола
---------------------------

В процессе авторизации используются две конечные точки сервера авторизации (ресурсы HTTP):

* Конечная точка авторизации - используется клиентом для получения авторизации от владельца ресурса через перенаправление пользовательского агента.
* Конечная точка токена - используется клиентом для обмена разрешения авторизации на токен доступа, обычно с аутентификацией клиента.

А также одна клиентская конечная точка:

* Конечная точка перенаправления - используется сервером авторизации для возврата клиенту ответов, содержащих учетные данные авторизации, через пользовательский агент владельца ресурса.

Не каждый тип разрешения на авторизацию использует обе конечные точки. Типы предоставления расширений МОГУТ определять дополнительные конечные точки по мере необходимости.

3.1. Конечная точка авторизации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Конечная точка авторизации используется для взаимодействия с владельцем ресурса и получения разрешения на авторизацию. Сервер авторизации ДОЛЖЕН сначала проверить личность владельца ресурса. Способ, которым сервер авторизации аутентифицирует владельца ресурса (например, имя пользователя и пароль для входа, файлы cookie сеанса), выходит за рамки данной спецификации.

Средства, с помощью которых клиент получает местоположение конечной точки авторизации, выходят за рамки данной спецификации, но местоположение обычно указывается в документации службы.

URI конечной точки МОЖЕТ включать компонент запроса в формате ``application/x-www-form-urlencoded`` (согласно Приложению B) ([RFC3986] раздел 3.4), который ДОЛЖЕН быть сохранен при добавлении дополнительных параметров запроса. URI конечной точки НЕ ДОЛЖЕН включать компонент фрагмента.

Поскольку запросы к конечной точке авторизации приводят к аутентификации пользователя и передаче учетных данных в открытом виде (в HTTP-ответе), сервер авторизации ДОЛЖЕН требовать использования TLS, как описано в разделе 1.6, при отправке запросов к конечной точке авторизации.

Сервер авторизации ДОЛЖЕН поддерживать использование метода HTTP "GET" [RFC2616] для конечной точки авторизации, а также МОЖЕТ поддерживать использование метода "POST".

Параметры, отправленные без значения, ДОЛЖНЫ обрабатываться так, как если бы они не были включены в запрос. Сервер авторизации ДОЛЖЕН игнорировать нераспознанные параметры запроса. Параметры запроса и ответа НЕ ДОЛЖНЫ включаться более одного раза.

3.1.1. Тип ответа
^^^^^^^^^^^^^^^^^

Конечная точка авторизации используется потоками типа предоставления кода авторизации и неявного типа предоставления. Клиент информирует сервер авторизации о желаемом типе гранта, используя следующий параметр:

response_type
    ОБЯЗАТЕЛЬНЫЙ. Значение ДОЛЖНО быть одним из ``code`` для запроса кода авторизации, как описано в разделе 4.1.1, ``token`` для запроса маркера доступа (неявное предоставление), как описано в разделе 4.2.1, или зарегистрированного значения расширения, как описано в Раздел 8.4.

Типы ответов расширения МОГУТ содержать список значений, разделенных пробелами (``%x20``), где порядок значений не имеет значения (например, тип ответа ``a b`` такой же, как ``b a``). Значение таких составных типов ответов определяется их соответствующими спецификациями.

Если в запросе авторизации отсутствует параметр response_type или если тип ответа не понят, сервер авторизации ДОЛЖЕН вернуть ответ с ошибкой, как описано в разделе 4.1.2.1.

3.1.2. Конечная точка перенаправления
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
После завершения взаимодействия с владельцем ресурса сервер авторизации направляет пользовательский агент владельца ресурса обратно клиенту. Сервер авторизации перенаправляет пользовательского агента к конечной точке перенаправления клиента, ранее установленной с сервером авторизации во время процесса регистрации клиента или при выполнении запроса авторизации.

URI конечной точки перенаправления ДОЛЖЕН быть абсолютным URI, как определено в разделе 4.3 [RFC3986]. URI конечной точки МОЖЕТ включать компонент запроса в формате ``application/x-www-form-urlencoded`` (согласно Приложению B) ([RFC3986] раздел 3.4), который ДОЛЖЕН быть сохранен при добавлении дополнительных параметров запроса. URI конечной точки НЕ ДОЛЖЕН включать компонент фрагмента.

3.1.2.1. Конфиденциальность запроса конечной точки
##################################################

Конечной точке перенаправления СЛЕДУЕТ требовать использования TLS, как описано в разделе 1.6, когда запрашиваемый тип ответа - ``code`` или ``token``, или когда запрос перенаправления приведет к передаче конфиденциальных учетных данных по открытой сети. Эта спецификация не требует обязательного использования TLS, поскольку на момент написания этой статьи требование развертывания TLS от клиентов было серьезным препятствием для многих разработчиков клиентов. Если TLS недоступен, серверу авторизации СЛЕДУЕТ предупредить владельца ресурса о небезопасной конечной точке до перенаправления (например, отображать сообщение во время запроса авторизации).

Отсутствие безопасности на транспортном уровне может серьезно повлиять на безопасность клиента и защищенных ресурсов, к которым ему разрешен доступ. Использование безопасности транспортного уровня особенно важно, когда процесс авторизации используется клиентом как форма делегированной аутентификации конечного пользователя (например, сторонняя служба входа в систему).

3.1.2.2. Требования к регистрации
#################################

Сервер авторизации ДОЛЖЕН требовать, чтобы следующие клиенты зарегистрировали свою конечную точку перенаправления:

* Публичные клиента (public).
* Конфиденциальные клиенты, использующие неявный тип предоставления (implicit).

Серверу авторизации СЛЕДУЕТ требовать, чтобы все клиенты зарегистрировали свою конечную точку перенаправления до использования конечной точки авторизации.

Серверу авторизации СЛЕДУЕТ требовать, чтобы клиент предоставил полный URI перенаправления (клиент МОЖЕТ использовать параметр запроса «состояние» для достижения индивидуальной настройки каждого запроса). Если требование регистрации полного URI перенаправления невозможно, серверу авторизации СЛЕДУЕТ потребовать регистрацию схемы URI, полномочий и пути (позволяя клиенту динамически изменять только компонент запроса URI перенаправления при запросе авторизации).

Сервер авторизации МОЖЕТ позволить клиенту зарегистрировать несколько конечных точек перенаправления.

Отсутствие требования регистрации URI перенаправления может позволить злоумышленнику использовать конечную точку авторизации в качестве открытого перенаправителя, как описано в Разделе 10.15.

3.1.2.3. Динамическая конфигурация
##################################

Если было зарегистрировано несколько URI перенаправления, если была зарегистрирована только часть URI перенаправления или если URI перенаправления не был зарегистрирован, клиент ДОЛЖЕН включить URI перенаправления в запрос авторизации с использованием параметра запроса redirect_uri.

Когда URI перенаправления включен в запрос авторизации, сервер авторизации ДОЛЖЕН сравнить и сопоставить полученное значение по крайней мере с одним из зарегистрированных URI перенаправления (или компонентов URI), как определено в разделе 6 [RFC3986], если какие-либо URI перенаправления были зарегистрированы . Если регистрация клиента включала полный URI перенаправления, сервер авторизации ДОЛЖЕН сравнить два URI, используя простое сравнение строк, как определено в разделе 6.2.1 [RFC3986].

3.1.2.4. Недействительная конечная точка
########################################

Если запрос авторизации не проходит проверку из-за отсутствия, недопустимого или несоответствующего URI перенаправления, серверу авторизации СЛЕДУЕТ проинформировать владельца ресурса об ошибке и НЕ ДОЛЖНО автоматически перенаправлять пользовательский агент на недопустимый URI перенаправления.

3.1.2.5. Контент конечной точки
###############################

Запрос перенаправления к конечной точке клиента обычно приводит к ответу документа HTML, обрабатываемому пользовательским агентом. Если ответ HTML обслуживается непосредственно в результате запроса перенаправления, любой сценарий, включенный в документ HTML, будет выполняться с полным доступом к URI перенаправления и учетным данным, которые он содержит.

Клиенту НЕ СЛЕДУЕТ включать какие-либо сторонние скрипты (например, стороннюю аналитику, социальные плагины, рекламные сети) в ответ конечной точки перенаправления. Вместо этого ему СЛЕДУЕТ извлечь учетные данные из URI и снова перенаправить пользовательский агент на другую конечную точку, не раскрывая учетные данные (в URI или в другом месте). Если сторонние скрипты включены, клиент ДОЛЖЕН гарантировать, что его собственные скрипты (используемые для извлечения и удаления учетных данных из URI) будут выполнены первыми.

3.2. Конечная точка токена
~~~~~~~~~~~~~~~~~~~~~~~~~~
