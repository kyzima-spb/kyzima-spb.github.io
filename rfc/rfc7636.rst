.. contents:: Содержание
   :depth: 5

Proof Key for Code Exchange by OAuth Public Clients
===================================================

1. Введение
-----------

Общедоступные клиенты OAuth 2.0 [RFC6749] уязвимы для атак с перехватом кода авторизации.

В этой атаке злоумышленник перехватывает код авторизации, возвращаемый из конечной точки авторизации, в пределах пути связи, не защищенного протоколом TLS, например, при обмене данными между приложениями в операционной системе клиента.

Как только злоумышленник получил доступ к коду авторизации, он может использовать его для получения токена доступа.

На рисунке 1 графически показана атака. На этапе (1) собственное приложение, работающее на конечном устройстве, таком как смартфон, выдает запрос авторизации OAuth 2.0 через браузер/операционную систему. URI конечной точки перенаправления в этом случае обычно использует настраиваемую схему URI. Шаг (1) выполняется через безопасный API, который невозможно перехватить, хотя потенциально может наблюдаться в сценариях расширенных атак. Затем запрос пересылается на сервер авторизации OAuth 2.0 на шаге (2). Поскольку OAuth требует использования TLS, этот обмен данными защищен TLS и не может быть перехвачен. Сервер авторизации возвращает код авторизации на шаге (3). На этапе (4) код авторизации возвращается запрашивающей стороне через URI конечной точки перенаправления, который был предоставлен на этапе (1).

Обратите внимание, что вредоносное приложение может зарегистрироваться в качестве обработчика пользовательской схемы в дополнение к законному приложению OAuth 2.0. После этого вредоносное приложение может перехватить код авторизации на шаге (4). Это позволяет злоумышленнику запросить и получить токен доступа на этапах (5) и (6) соответственно. ::

    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
    | End Device (e.g., Smartphone)  |
    |                                |
    | +-------------+   +----------+ | (6) Access Token  +----------+
    | |Legitimate   |   | Malicious|<--------------------|          |
    | |OAuth 2.0 App|   | App      |-------------------->|          |
    | +-------------+   +----------+ | (5) Authorization |          |
    |        |    ^          ^       |        Grant      |          |
    |        |     \         |       |                   |          |
    |        |      \   (4)  |       |                   |          |
    |    (1) |       \  Authz|       |                   |          |
    |   Authz|        \ Code |       |                   |  Authz   |
    | Request|         \     |       |                   |  Server  |
    |        |          \    |       |                   |          |
    |        |           \   |       |                   |          |
    |        v            \  |       |                   |          |
    | +----------------------------+ |                   |          |
    | |                            | | (3) Authz Code    |          |
    | |     Operating System/      |<--------------------|          |
    | |         Browser            |-------------------->|          |
    | |                            | | (2) Authz Request |          |
    | +----------------------------+ |                   +----------+
    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

             Рисунок 1: Атака с перехватом кода авторизации

Чтобы эта атака сработала, необходимо выполнить ряд предварительных условий:

#. Злоумышленнику удается зарегистрировать вредоносное приложение на клиентском устройстве и зарегистрировать пользовательскую схему URI, которая также используется другим приложением. Операционные системы должны позволять регистрировать пользовательскую схему URI несколькими приложениями.
#. Используется код авторизации OAuth 2.0.
#. Злоумышленник имеет доступ к OAuth 2.0 [RFC6749] ``client_id`` и ``client_secret`` (если они предоставлены). Все клиентские экземпляры нативных приложений OAuth 2.0 используют один и тот же ``client_id``. Секреты, предоставленные в клиентских двоичных приложениях, не могут считаться конфиденциальными.
#. Выполнено одно из следующих условий:
    #. Злоумышленник (через установленное приложение) может наблюдать только ответы от конечной точки авторизации. Когда значение ``code_challenge_method`` равно ``"plain"``, смягчается только эта атака.
    #. Более изощренный сценарий атаки позволяет злоумышленнику наблюдать за запросами (в дополнение к ответам) к конечной точке авторизации. Однако злоумышленник не может действовать как человек посередине. Это было вызвано утечкой информации журнала http в ОС. Чтобы смягчить это, значение ``code_challenge_method`` должно быть установлено либо на ``S256``, либо на значение, определенное криптографически безопасным расширением ``code_challenge_method``.

Несмотря на то, что это длинный список предварительных условий, описанная атака наблюдалась в реальных условиях и должна учитываться при развертывании OAuth 2.0. Хотя модель угроз OAuth 2.0 (раздел 4.4.1 [RFC6819]) описывает методы смягчения, они, к сожалению, не применимы, поскольку они полагаются на секрет экземпляра для каждого клиента или URI перенаправления экземпляра для каждого клиента.

Чтобы смягчить эту атаку, это расширение использует динамически созданный криптографически случайный ключ, называемый «верификатором кода» (code verifier). Для каждого запроса авторизации создается уникальный верификатор кода, и его преобразованное значение, называемое «запрос кода» (code challenge), отправляется на сервер авторизации для получения кода авторизации. Полученный код авторизации затем отправляется в конечную точку токена с помощью «верификатора кода», и сервер сравнивает его с ранее полученным кодом запроса, чтобы он мог выполнить подтверждение владения «верификатором кода» клиентом. Это работает как смягчение, поскольку злоумышленник не узнает этот одноразовый ключ, поскольку он отправляется через TLS и не может быть перехвачен.

1.1. Поток протокола
~~~~~~~~~~~~~~~~~~~~

 ::

    .                                         +-------------------+
    .                                         |   Authz Server    |
    +--------+                                | +---------------+ |
    |        |--(A)- Authorization Request ---->|               | |
    |        |       + t(code_verifier), t_m  | | Authorization | |
    |        |                                | |    Endpoint   | |
    |        |<-(B)---- Authorization Code -----|               | |
    |        |                                | +---------------+ |
    | Client |                                |                   |
    |        |                                | +---------------+ |
    |        |--(C)-- Access Token Request ---->|               | |
    |        |          + code_verifier       | |    Token      | |
    |        |                                | |   Endpoint    | |
    |        |<-(D)------ Access Token ---------|               | |
    +--------+                                | +---------------+ |
                                              +-------------------+

                 Рисунок 2: Абстрактный поток протокола

Эта спецификация добавляет дополнительные параметры к запросам авторизации и токена доступа OAuth 2.0, которые показаны в абстрактной форме на рисунке 2.

:(A): Клиент создает и записывает секрет с именем ``code_verifier`` и получает преобразованную версию ``t(code_verifier)`` (называемую ``code_challenge``), которая отправляется в запросе авторизации OAuth 2.0 вместе с методом преобразования ``t_m``.

:(B): Конечная точка авторизации отвечает как обычно, но записывает ``t(code_verifier)`` и метод преобразования.

:(C): Затем клиент отправляет код авторизации в запросе токена доступа, как обычно, но включает секрет ``code_verifier``, сгенерированный в (A).

:(D): Сервер авторизации преобразует ``code_verifier`` и сравнивает его с ``t(code_verifier)`` из (B). Доступ запрещен, если они не равны.

Злоумышленник, который перехватывает код авторизации в (B), не может обменять его на токен доступа, так как он не владеет секретом ``code_verifier``.

3. Терминология
---------------

В дополнение к терминам, определенным в OAuth 2.0 [RFC6749], эта спецификация определяет следующие термины:

code verifier
    Криптографически случайная строка, которая используется для сопоставления запроса авторизации с запросом токена.

code challenge
    Вызов, полученный от верификатора кода, который отправляется в запросе авторизации, для последующей проверки.

code challenge method
    Метод, который использовался для получения вызова кода.

Base64url Encoding
    Кодирование Base64 с использованием набора символов, безопасных для URL-адресов и имен файлов, определенного в разделе 5 [RFC4648], с опущением всех завершающих символов '=' (как разрешено в разделе 3.2 документа [RFC4648]) и без включения каких-либо разрывов строк, пробелов или других дополнительных символов. (См. В Приложении A примечания по реализации кодировки base64url без заполнения.)

3.1. Сокращения
~~~~~~~~~~~~~~~

ABNF - Расширенная форма Бэкуса-Наура

Authz - Авторизация

PKCE - Пробный ключ для обмена кодами

MITM - Человек посередине

MTI - обязательный к реализации

4. Протокол
-----------

4.1. Клиент создает верификатор кода
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сначала клиент создает верификатор кода code_verifier для каждого запроса авторизации OAuth 2.0 [RFC6749] следующим образом:

``code_verifier`` = криптографическая случайная строка с высокой энтропией с использованием незарезервированных символов [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~" из раздела 2.3 [RFC3986] с минимальной длиной 43 символа и максимальной длиной 128 символов.

ABNF для «code_verifier» выглядит следующим образом::

    code-verifier = 43*128unreserved
    unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    ALPHA = %x41-5A / %x61-7A
    DIGIT = %x30-39

ПРИМЕЧАНИЕ: Верификатор кода ДОЛЖЕН иметь достаточную энтропию, чтобы сделать нецелесообразным угадывание значения. Рекомендуется использовать выход подходящего генератора случайных чисел для создания 32-октетной последовательности. Затем последовательность октетов кодируется base64url для получения 43-октетной безопасной строки URL для использования в качестве верификатора кода.

4.2. Клиент создает Code Challenge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем клиент создает code challenge, полученный из верификатора кода, используя одно из следующих преобразований в верификаторе кода::

    plain
        code_challenge = code_verifier

    S256
        code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))

Если клиент может использовать «S256», он ДОЛЖЕН использовать «S256», поскольку «S256» является обязательным для реализации (MTI) на сервере. Клиентам разрешается использовать "простой", только если они не могут поддерживать "S256" по какой-либо технической причине и знают через внеполосную конфигурацию, что сервер поддерживает "простой".

Простое преобразование предназначено для совместимости с существующими развертываниями и для ограниченных сред, которые не могут использовать преобразование S256.

ABNF для ``code_challenge`` выглядит следующим образом::

    code-challenge = 43*128unreserved
    unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    ALPHA = %x41-5A / %x61-7A
    DIGIT = %x30-39

4.3. Клиент отправляет Code Challenge с запросом на авторизацию
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Клиент отправляет code challenge как часть запроса авторизации OAuth 2.0 (раздел 4.1.1 [RFC6749]), используя следующие дополнительные параметры:

code_challenge
    ОБЯЗАТЕЛЬНЫЙ. Code challenge.

code_challenge_method
    НЕОБЯЗАТЕЛЬНЫЙ, по умолчанию используется ``plain``, если он не указан в запросе. Метод преобразования верификатора кода - `S256` или ``plain``.

4.4. Сервер возвращает код
~~~~~~~~~~~~~~~~~~~~~~~~~~

