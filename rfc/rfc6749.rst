.. contents:: Содержание
   :depth: 3

The OAuth 2.0 Authorization Framework
=====================================

2. Регистрация клиента
----------------------

Перед запуском протокола клиент регистрируется на сервере авторизации. Средства, с помощью которых клиент регистрируется на сервере авторизации, выходят за рамки данной спецификации, но обычно включают взаимодействие конечного пользователя с регистрационной формой HTML.

Регистрация клиента не требует прямого взаимодействия между клиентом и сервером авторизации. При поддержке сервера авторизации регистрация может полагаться на другие средства для установления доверия и получения требуемых свойств клиента (например, URI перенаправления, типа клиента). Например, регистрация может быть выполнена с использованием утверждения, выданного самостоятельно или третьей стороной, или сервером авторизации, выполняющим обнаружение клиента с использованием доверенного канала.

При регистрации клиента разработчик клиента ОБЯЗАН:

* указать тип клиента, как описано в разделе 2.1
* предоставить свои URI перенаправления клиента, как описано в Разделе 3.1.2
* включать любую другую информацию, требуемую сервером авторизации (например, название приложения, веб-сайт, описание, изображение логотипа, принятие юридических условий).

2.1. Типы клиентов
~~~~~~~~~~~~~~~~~~

OAuth определяет два типа клиентов в зависимости от их способности безопасно аутентифицироваться с помощью сервера авторизации (т.е. Способности поддерживать конфиденциальность своих учетных данных клиента):

confidential
    Клиенты, способные поддерживать конфиденциальность своих учетных данных (например, клиент, реализованный на защищенном сервере с ограниченным доступом к учетным данным клиента) или способные к безопасной аутентификации клиента с использованием других средств.

public
    Клиенты, неспособные поддерживать конфиденциальность своих учетных данных (например, клиенты, выполняющиеся на устройстве, используемом владельцем ресурса, таком как установленное собственное приложение или приложение на основе веб-браузера), и неспособные к безопасной аутентификации клиента с помощью любых других средств.

Обозначение типа клиента основано на определении сервером авторизации безопасной аутентификации и приемлемых уровнях раскрытия учетных данных клиента. Серверу авторизации НЕ СЛЕДУЕТ делать предположения о типе клиента.

Клиент может быть реализован как распределенный набор компонентов, каждый с различным типом клиента и контекстом безопасности (например, распределенный клиент с конфиденциальным серверным компонентом и общедоступным компонентом на основе браузера). Если сервер авторизации не поддерживает таких клиентов или не дает рекомендаций по их регистрации, клиент ДОЛЖЕН зарегистрировать каждый компонент как отдельный клиент.

Эта спецификация была разработана для следующих клиентских профилей:

веб приложение (web application)
    Веб-приложение - это конфиденциальный клиент, работающий на веб-сервере. Владельцы ресурсов получают доступ к клиенту через пользовательский интерфейс HTML, отображаемый в пользовательском агенте на устройстве, используемом владельцем ресурса. Учетные данные клиента, а также любой токен доступа, выданный клиенту, хранятся на веб-сервере и не доступны для владельца ресурса.

приложение на основе пользовательского агента (user-agent-based application)
    Приложение на основе пользовательского агента - это общедоступный клиент, в котором клиентский код загружается с веб-сервера и выполняется в рамках пользовательского агента (например, веб-браузера) на устройстве, используемом владельцем ресурса. Данные протокола и учетные данные легко доступны (и часто видны) владельцу ресурса. Поскольку такие приложения находятся в пользовательском агенте, они могут беспрепятственно использовать возможности пользовательского агента при запросе авторизации.

собственное приложение (native application)
    Собственное приложение - это общедоступный клиент, установленный и выполняемый на устройстве, используемом владельцем ресурса. Данные протокола и учетные данные доступны владельцу ресурса. Предполагается, что любые учетные данные для аутентификации клиента, включенные в приложение, могут быть извлечены. С другой стороны, динамически выдаваемые учетные данные, такие как токены доступа или токены обновления, могут получить приемлемый уровень защиты. Как минимум, эти учетные данные защищены от враждебных серверов, с которыми приложение может взаимодействовать. На некоторых платформах эти учетные данные могут быть защищены от других приложений, находящихся на том же устройстве.

2.2. Идентификация клиента
~~~~~~~~~~~~~~~~~~~~~~~~~~

Сервер авторизации выдает зарегистрированному клиенту идентификатор клиента - уникальную строку, представляющую регистрационную информацию, предоставленную клиентом. Идентификатор клиента не секрет; он предоставляется владельцу ресурса и НЕ ДОЛЖЕН использоваться отдельно для аутентификации клиента. Идентификатор клиента уникален для сервера авторизации.

Размер строки идентификатора клиента не определен данной спецификацией. Клиент должен избегать предположений о размере идентификатора. Серверу авторизации СЛЕДУЕТ задокументировать размер любого выдаваемого им идентификатора.

2.3. Проверка подлинности клиента
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если тип клиента является конфиденциальным, клиент и сервер авторизации устанавливают метод аутентификации клиента, подходящий для требований безопасности сервера авторизации. Сервер авторизации МОЖЕТ принимать любую форму аутентификации клиента, отвечающую его требованиям безопасности.

Конфиденциальным клиентам обычно выдается (или устанавливается) набор учетных данных клиента, используемых для аутентификации на сервере авторизации (например, пароль, пара открытого / закрытого ключей). Сервер авторизации МОЖЕТ установить метод аутентификации клиента с общедоступными клиентами. Однако сервер авторизации НЕ ДОЛЖЕН полагаться на общедоступную аутентификацию клиента с целью идентификации клиента.

Клиент НЕ ДОЛЖЕН использовать более одного метода аутентификации в каждом запросе.

2.3.1. Пароль клиента
^^^^^^^^^^^^^^^^^^^^^

Клиенты, владеющие клиентским паролем, МОГУТ использовать схему аутентификации HTTP Basic, как определено в [RFC2617], для аутентификации на сервере авторизации. Идентификатор клиента кодируется с использованием алгоритма кодирования «application / x-www-form-urlencoded» согласно Приложению B, и закодированное значение используется в качестве имени пользователя; пароль клиента кодируется с использованием того же алгоритма и используется в качестве пароля. Сервер авторизации ДОЛЖЕН поддерживать схему аутентификации HTTP Basic для аутентификации клиентов, которым был выдан пароль клиента.

Например (с дополнительными разрывами строк только для отображения)::

    Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3

В качестве альтернативы сервер авторизации МОЖЕТ поддерживать включение учетных данных клиента в тело запроса с использованием следующих параметров:

client_id
    ОБЯЗАТЕЛЬНЫЙ. Идентификатор клиента, выданный клиенту во время процесса регистрации, описанного в разделе 2.2.

client_secret
    ОБЯЗАТЕЛЬНЫЙ. Секрет клиента. Клиент МОЖЕТ опустить параметр, если секрет клиента является пустой строкой.

Включение учетных данных клиента в тело запроса с использованием этих двух параметров НЕ РЕКОМЕНДУЕТСЯ и ДОЛЖНО быть ограничено клиентами, которые не могут напрямую использовать схему аутентификации HTTP Basic (или другие схемы аутентификации HTTP на основе пароля). Параметры могут быть переданы только в теле запроса и НЕ ДОЛЖНЫ включаться в URI запроса.

Например, запрос на обновление токена доступа (раздел 6) с использованием параметров тела (с дополнительными разрывами строк только для отображения)::

    POST /token HTTP/1.1
    Host: server.example.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
    &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw

Сервер авторизации ДОЛЖЕН требовать использования TLS, как описано в разделе 1.6, при отправке запросов с использованием аутентификации по паролю.

Поскольку этот метод аутентификации клиента включает в себя пароль, сервер авторизации ДОЛЖЕН защищать любую конечную точку, использующую его, от brute force атак.

2.3.2. Другие методы аутентификации
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Сервер авторизации МОЖЕТ поддерживать любую подходящую схему аутентификации HTTP, соответствующую его требованиям безопасности. При использовании других методов аутентификации сервер авторизации ДОЛЖЕН определить соответствие между идентификатором клиента (регистрационной записью) и схемой аутентификации.

2.4. Незарегистрированные клиенты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Эта спецификация не исключает использования незарегистрированных клиентов. Однако использование таких клиентов выходит за рамки данной спецификации и требует дополнительного анализа безопасности и анализа влияния на совместимость.

3. Конечные точки протокола
---------------------------

В процессе авторизации используются две конечные точки сервера авторизации (ресурсы HTTP):

* Конечная точка авторизации - используется клиентом для получения авторизации от владельца ресурса через перенаправление пользовательского агента.
* Конечная точка токена - используется клиентом для обмена разрешения авторизации на токен доступа, обычно с аутентификацией клиента.

А также одна клиентская конечная точка:

* Конечная точка перенаправления - используется сервером авторизации для возврата клиенту ответов, содержащих учетные данные авторизации, через пользовательский агент владельца ресурса.

Не каждый тип разрешения на авторизацию использует обе конечные точки. Типы предоставления расширений МОГУТ определять дополнительные конечные точки по мере необходимости.

