.. contents:: Содержание
   :depth: 5

Proof Key for Code Exchange by OAuth Public Clients
===================================================

1. Введение
-----------

Общедоступные клиенты OAuth 2.0 [RFC6749] уязвимы для атак с перехватом кода авторизации.

В этой атаке злоумышленник перехватывает код авторизации, возвращаемый из конечной точки авторизации, в пределах пути связи, не защищенного протоколом TLS, например, при обмене данными между приложениями в операционной системе клиента.

Как только злоумышленник получил доступ к коду авторизации, он может использовать его для получения токена доступа.

На рисунке 1 графически показана атака. На этапе (1) собственное приложение, работающее на конечном устройстве, таком как смартфон, выдает запрос авторизации OAuth 2.0 через браузер/операционную систему. URI конечной точки перенаправления в этом случае обычно использует настраиваемую схему URI. Шаг (1) выполняется через безопасный API, который невозможно перехватить, хотя потенциально может наблюдаться в сценариях расширенных атак. Затем запрос пересылается на сервер авторизации OAuth 2.0 на шаге (2). Поскольку OAuth требует использования TLS, этот обмен данными защищен TLS и не может быть перехвачен. Сервер авторизации возвращает код авторизации на шаге (3). На этапе (4) код авторизации возвращается запрашивающей стороне через URI конечной точки перенаправления, который был предоставлен на этапе (1).

Обратите внимание, что вредоносное приложение может зарегистрироваться в качестве обработчика пользовательской схемы в дополнение к законному приложению OAuth 2.0. После этого вредоносное приложение может перехватить код авторизации на шаге (4). Это позволяет злоумышленнику запросить и получить токен доступа на этапах (5) и (6) соответственно. ::

    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
    | End Device (e.g., Smartphone)  |
    |                                |
    | +-------------+   +----------+ | (6) Access Token  +----------+
    | |Legitimate   |   | Malicious|<--------------------|          |
    | |OAuth 2.0 App|   | App      |-------------------->|          |
    | +-------------+   +----------+ | (5) Authorization |          |
    |        |    ^          ^       |        Grant      |          |
    |        |     \         |       |                   |          |
    |        |      \   (4)  |       |                   |          |
    |    (1) |       \  Authz|       |                   |          |
    |   Authz|        \ Code |       |                   |  Authz   |
    | Request|         \     |       |                   |  Server  |
    |        |          \    |       |                   |          |
    |        |           \   |       |                   |          |
    |        v            \  |       |                   |          |
    | +----------------------------+ |                   |          |
    | |                            | | (3) Authz Code    |          |
    | |     Operating System/      |<--------------------|          |
    | |         Browser            |-------------------->|          |
    | |                            | | (2) Authz Request |          |
    | +----------------------------+ |                   +----------+
    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

             Рисунок 1: Атака с перехватом кода авторизации

Чтобы эта атака сработала, необходимо выполнить ряд предварительных условий:

#. Злоумышленнику удается зарегистрировать вредоносное приложение на клиентском устройстве и зарегистрировать пользовательскую схему URI, которая также используется другим приложением. Операционные системы должны позволять регистрировать пользовательскую схему URI несколькими приложениями.
#. Используется код авторизации OAuth 2.0.
#. Злоумышленник имеет доступ к OAuth 2.0 [RFC6749] ``client_id`` и ``client_secret`` (если они предоставлены). Все клиентские экземпляры нативных приложений OAuth 2.0 используют один и тот же ``client_id``. Секреты, предоставленные в клиентских двоичных приложениях, не могут считаться конфиденциальными.
#. Выполнено одно из следующих условий:
    #. Злоумышленник (через установленное приложение) может наблюдать только ответы от конечной точки авторизации. Когда значение ``code_challenge_method`` равно ``"plain"``, смягчается только эта атака.

    #. Более изощренный сценарий атаки позволяет злоумышленнику наблюдать за запросами (в дополнение к ответам) к конечной точке авторизации. Однако злоумышленник не может действовать как человек посередине. Это было вызвано утечкой информации журнала http в ОС. Чтобы смягчить это, значение ``code_challenge_method`` должно быть установлено либо на ``S256``, либо на значение, определенное криптографически безопасным расширением ``code_challenge_method``.

Несмотря на то, что это длинный список предварительных условий, описанная атака наблюдалась в реальных условиях и должна учитываться при развертывании OAuth 2.0. Хотя модель угроз OAuth 2.0 (раздел 4.4.1 [RFC6819]) описывает методы смягчения, они, к сожалению, не применимы, поскольку они полагаются на секрет экземпляра для каждого клиента или URI перенаправления экземпляра для каждого клиента.

Чтобы смягчить эту атаку, это расширение использует динамически созданный криптографически случайный ключ, называемый «верификатором кода» (code verifier). Для каждого запроса авторизации создается уникальный верификатор кода, и его преобразованное значение, называемое «запрос кода» (code challenge), отправляется на сервер авторизации для получения кода авторизации. Полученный код авторизации затем отправляется в конечную точку токена с помощью «верификатора кода», и сервер сравнивает его с ранее полученным кодом запроса, чтобы он мог выполнить подтверждение владения «верификатором кода» клиентом. Это работает как смягчение, поскольку злоумышленник не узнает этот одноразовый ключ, поскольку он отправляется через TLS и не может быть перехвачен.

1.1. Поток протокола
~~~~~~~~~~~~~~~~~~~~

 ::

    .                                         +-------------------+
    .                                         |   Authz Server    |
    +--------+                                | +---------------+ |
    |        |--(A)- Authorization Request ---->|               | |
    |        |       + t(code_verifier), t_m  | | Authorization | |
    |        |                                | |    Endpoint   | |
    |        |<-(B)---- Authorization Code -----|               | |
    |        |                                | +---------------+ |
    | Client |                                |                   |
    |        |                                | +---------------+ |
    |        |--(C)-- Access Token Request ---->|               | |
    |        |          + code_verifier       | |    Token      | |
    |        |                                | |   Endpoint    | |
    |        |<-(D)------ Access Token ---------|               | |
    +--------+                                | +---------------+ |
                                              +-------------------+

                 Рисунок 2: Абстрактный поток протокола

Эта спецификация добавляет дополнительные параметры к запросам авторизации и токена доступа OAuth 2.0, которые показаны в абстрактной форме на рисунке 2.

:(A): Клиент создает и записывает секрет с именем ``code_verifier`` и получает преобразованную версию ``t(code_verifier)`` (называемую ``code_challenge``), которая отправляется в запросе авторизации OAuth 2.0 вместе с методом преобразования ``t_m``.

:(B): Конечная точка авторизации отвечает как обычно, но записывает ``t(code_verifier)`` и метод преобразования.

:(C): Затем клиент отправляет код авторизации в запросе токена доступа, как обычно, но включает секрет ``code_verifier``, сгенерированный в (A).

:(D): Сервер авторизации преобразует ``code_verifier`` и сравнивает его с ``t(code_verifier)`` из (B). Доступ запрещен, если они не равны.

Злоумышленник, который перехватывает код авторизации в (B), не может обменять его на токен доступа, так как он не владеет секретом ``code_verifier``.
